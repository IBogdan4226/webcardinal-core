/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { WebcAppLoaderType } from "./interfaces";
import { RouterHistory } from "@stencil/router";
export namespace Components {
    interface WebcAppContainer {
    }
    interface WebcAppErrorToast {
    }
    interface WebcAppIdentity {
        /**
          * Path or URL to an image.
         */
        "avatar"?: string | null;
        /**
          * Email of your brand or organization.
         */
        "email": string | null;
        /**
          * Name of your brand or organization.
         */
        "name": string | null;
    }
    interface WebcAppLoader {
        /**
          * Fetch a HTML file and loads inside as normal children or in a wrapped manner.
         */
        "loader": WebcAppLoaderType;
        /**
          * Source path for a HTML page.
         */
        "src": string;
    }
    interface WebcAppMenu {
        /**
          * There is the possibility to change the base path of your application, using <code>base</code> HTML Element: <psk-example>    <psk-code>     <base href="/my-custom-base">    </psk-code> </psk-example>  Both <code>webc-app-menu</code> and <code>webc-app-router</code> must share the same <code>basePath</code>.
         */
        "basePath": string;
        /**
          * Decides if <code>webc-app-identity</code> is rendered.<br> This property is set by Custom Variable <code>--webc-app-menu-disable-identity</code>.
         */
        "disableIdentity": boolean;
        /**
          * This Array is received from <code>ApplicationController</code>.
         */
        "items": any[];
        "mode": string;
    }
    interface WebcAppMenuItem {
        "activate": () => Promise<void>;
        "basePath": string;
        "deactivate": () => Promise<void>;
        "item": { path: string; children: any; };
        "level": number;
        "menuElement": HTMLElement;
        "mode": string;
        "name": string;
        "url": string | null;
    }
    interface WebcAppRedirect {
        "url": string;
    }
    interface WebcAppRoot {
        "history": RouterHistory;
        /**
          * Component tag name (in lowercase) for a UI loader.
         */
        "loaderName": string;
    }
    interface WebcAppRouter {
        /**
          * There is the possibility to change the base path of your application, using <code>base</code> HTML Element: <psk-example>    <psk-code>     <base href="/my-custom-base">    </psk-code> </psk-example>  Both <code>webc-app-router</code> and <code>webc-app-menu</code> must share the same <code>basePath</code>.
         */
        "basePath": string;
        /**
          * Similar to 404 page, if <code>window.location.href</code> does not match any page, this fallback will be shown. This page can be changed from <code>webcardinal.json</code>, using <code>pagesFallback</code>.
         */
        "fallbackPage": any;
        /**
          * Path to <code>/pages</code> folder.<br> This folder can be changed from <code>webcardinal.json</code>, using <code>pagesPathname</code>.
         */
        "pagesPath": string;
        /**
          * This Array is received from <code>ApplicationController</code>.
         */
        "routes": any[];
    }
    interface WebcContainer {
        /**
          * This property is a string that will permit the developer to choose his own controller. If no value is set then the null default value will be taken and the component will use the basic Controller.
         */
        "controllerName": string | null;
        /**
          * If it is not specified, all the innerHTML will be placed inside the unnamed slot. Otherwise the content will replace the <code>webc-container</code> element form DOM.
         */
        "disableContainer": boolean;
        /**
          * If this property is true, internationalization (i18n) will be enabled.
         */
        "enableTranslations": boolean;
        /**
          * The model from controller is exposed by this method.
         */
        "getModel": () => Promise<any>;
        /**
          * The translation model from controller is exposed by this method.
         */
        "getTranslationModel": () => Promise<any>;
        "history": RouterHistory;
    }
    interface WebcDocs {
        /**
          * Component tag name (in lowercase) for which documentation is desired.
         */
        "for": string;
        /**
          * If this prop is set to <code>true</code> the source of fetched docs for current webc-docs component must be on your local workspace. Otherwise the source is <small><code>https://raw.githubusercontent.com</code></small>.
         */
        "local"?: boolean;
    }
    interface WebcLink {
        "href": string | null;
        /**
          * A unique identifier for each page, which was previously set in <code>webcardinal.json</code>
         */
        "tag": string | null;
    }
    interface WebcModal {
        /**
          * Sets if the modal will automatically close when the user clicks outside of it.
         */
        "autoClose": boolean;
        /**
          * Sets if the modal will automatically show when the element is constructed.
         */
        "autoShow": boolean;
        /**
          * Sets if the modal can be closed
         */
        "canClose": boolean;
        /**
          * The text that will appear on the footer close button, if neither the "footer" slot nor modalFooterContent are provided.
         */
        "cancelButtonText": string;
        /**
          * Sets if the popup is centered on the screen or if it appear at the top of the screen.
         */
        "centered": boolean;
        /**
          * The text that will appear on the footer confirm button, if neither the "footer" slot nor modalFooterContent are provided.
         */
        "confirmButtonText": string;
        /**
          * Method that completely removes the modal from the DOM.
         */
        "destroy": () => Promise<void>;
        /**
          * Method that hides the modal.
         */
        "hide": () => Promise<void>;
        /**
          * The content that can be shown in the footer, if provided and the "footer" slot is missing from the content.
         */
        "modalFooterContent": string;
        /**
          * The name of the model that will be loaded. The generated path will have the format <code>${basePath}/modals/${modalName}.html</code>.
         */
        "modalName": string;
        /**
          * The text that will be shown in the modal's header, if neither the "title" slot nor modalTitleContent are provided.
         */
        "modalTitle": string;
        /**
          * The content that can be shown in the header, if provided and the "title" slot is missing from the content.
         */
        "modalTitleContent": string;
        /**
          * Method that shows the modal.
         */
        "show": () => Promise<void>;
        /**
          * Sets if the close button will be shown or not.
         */
        "showCancelButton": boolean;
        /**
          * Sets if the modal has the footer displayed.
         */
        "showFooter": boolean;
        /**
          * The content that will be shown in the modal body, if modalName is not provided.
         */
        "text": string;
    }
    interface WebcSkin {
        /**
          * Path to a stylesheet.
         */
        "href": string;
    }
    interface WebcSpinner {
    }
    interface WebcTemplate {
        "chain": string;
        /**
          * If it is not specified, all the markup coming <code>template</code> attribute will be placed inside innerHTML after the unnamed slot. Otherwise the content will replace the <code>webc-template</code> element form DOM.
         */
        "disableContainer": boolean;
        /**
          * The name of the template that will be loaded. The generated path will have the format <code>${basePath}/templates/${templateName}.html</code>.
         */
        "templateName": string;
    }
}
declare global {
    interface HTMLWebcAppContainerElement extends Components.WebcAppContainer, HTMLStencilElement {
    }
    var HTMLWebcAppContainerElement: {
        prototype: HTMLWebcAppContainerElement;
        new (): HTMLWebcAppContainerElement;
    };
    interface HTMLWebcAppErrorToastElement extends Components.WebcAppErrorToast, HTMLStencilElement {
    }
    var HTMLWebcAppErrorToastElement: {
        prototype: HTMLWebcAppErrorToastElement;
        new (): HTMLWebcAppErrorToastElement;
    };
    interface HTMLWebcAppIdentityElement extends Components.WebcAppIdentity, HTMLStencilElement {
    }
    var HTMLWebcAppIdentityElement: {
        prototype: HTMLWebcAppIdentityElement;
        new (): HTMLWebcAppIdentityElement;
    };
    interface HTMLWebcAppLoaderElement extends Components.WebcAppLoader, HTMLStencilElement {
    }
    var HTMLWebcAppLoaderElement: {
        prototype: HTMLWebcAppLoaderElement;
        new (): HTMLWebcAppLoaderElement;
    };
    interface HTMLWebcAppMenuElement extends Components.WebcAppMenu, HTMLStencilElement {
    }
    var HTMLWebcAppMenuElement: {
        prototype: HTMLWebcAppMenuElement;
        new (): HTMLWebcAppMenuElement;
    };
    interface HTMLWebcAppMenuItemElement extends Components.WebcAppMenuItem, HTMLStencilElement {
    }
    var HTMLWebcAppMenuItemElement: {
        prototype: HTMLWebcAppMenuItemElement;
        new (): HTMLWebcAppMenuItemElement;
    };
    interface HTMLWebcAppRedirectElement extends Components.WebcAppRedirect, HTMLStencilElement {
    }
    var HTMLWebcAppRedirectElement: {
        prototype: HTMLWebcAppRedirectElement;
        new (): HTMLWebcAppRedirectElement;
    };
    interface HTMLWebcAppRootElement extends Components.WebcAppRoot, HTMLStencilElement {
    }
    var HTMLWebcAppRootElement: {
        prototype: HTMLWebcAppRootElement;
        new (): HTMLWebcAppRootElement;
    };
    interface HTMLWebcAppRouterElement extends Components.WebcAppRouter, HTMLStencilElement {
    }
    var HTMLWebcAppRouterElement: {
        prototype: HTMLWebcAppRouterElement;
        new (): HTMLWebcAppRouterElement;
    };
    interface HTMLWebcContainerElement extends Components.WebcContainer, HTMLStencilElement {
    }
    var HTMLWebcContainerElement: {
        prototype: HTMLWebcContainerElement;
        new (): HTMLWebcContainerElement;
    };
    interface HTMLWebcDocsElement extends Components.WebcDocs, HTMLStencilElement {
    }
    var HTMLWebcDocsElement: {
        prototype: HTMLWebcDocsElement;
        new (): HTMLWebcDocsElement;
    };
    interface HTMLWebcLinkElement extends Components.WebcLink, HTMLStencilElement {
    }
    var HTMLWebcLinkElement: {
        prototype: HTMLWebcLinkElement;
        new (): HTMLWebcLinkElement;
    };
    interface HTMLWebcModalElement extends Components.WebcModal, HTMLStencilElement {
    }
    var HTMLWebcModalElement: {
        prototype: HTMLWebcModalElement;
        new (): HTMLWebcModalElement;
    };
    interface HTMLWebcSkinElement extends Components.WebcSkin, HTMLStencilElement {
    }
    var HTMLWebcSkinElement: {
        prototype: HTMLWebcSkinElement;
        new (): HTMLWebcSkinElement;
    };
    interface HTMLWebcSpinnerElement extends Components.WebcSpinner, HTMLStencilElement {
    }
    var HTMLWebcSpinnerElement: {
        prototype: HTMLWebcSpinnerElement;
        new (): HTMLWebcSpinnerElement;
    };
    interface HTMLWebcTemplateElement extends Components.WebcTemplate, HTMLStencilElement {
    }
    var HTMLWebcTemplateElement: {
        prototype: HTMLWebcTemplateElement;
        new (): HTMLWebcTemplateElement;
    };
    interface HTMLElementTagNameMap {
        "webc-app-container": HTMLWebcAppContainerElement;
        "webc-app-error-toast": HTMLWebcAppErrorToastElement;
        "webc-app-identity": HTMLWebcAppIdentityElement;
        "webc-app-loader": HTMLWebcAppLoaderElement;
        "webc-app-menu": HTMLWebcAppMenuElement;
        "webc-app-menu-item": HTMLWebcAppMenuItemElement;
        "webc-app-redirect": HTMLWebcAppRedirectElement;
        "webc-app-root": HTMLWebcAppRootElement;
        "webc-app-router": HTMLWebcAppRouterElement;
        "webc-container": HTMLWebcContainerElement;
        "webc-docs": HTMLWebcDocsElement;
        "webc-link": HTMLWebcLinkElement;
        "webc-modal": HTMLWebcModalElement;
        "webc-skin": HTMLWebcSkinElement;
        "webc-spinner": HTMLWebcSpinnerElement;
        "webc-template": HTMLWebcTemplateElement;
    }
}
declare namespace LocalJSX {
    interface WebcAppContainer {
    }
    interface WebcAppErrorToast {
    }
    interface WebcAppIdentity {
        /**
          * Path or URL to an image.
         */
        "avatar"?: string | null;
        /**
          * Email of your brand or organization.
         */
        "email"?: string | null;
        /**
          * Name of your brand or organization.
         */
        "name"?: string | null;
        /**
          * All properties enumerated before are automatically filled by webc-app-identity when this event is fired from <code>ApplicationController</code>.
         */
        "onWebcardinal:config:getIdentity"?: (event: CustomEvent<any>) => void;
    }
    interface WebcAppLoader {
        /**
          * Fetch a HTML file and loads inside as normal children or in a wrapped manner.
         */
        "loader"?: WebcAppLoaderType;
        /**
          * Source path for a HTML page.
         */
        "src"?: string;
    }
    interface WebcAppMenu {
        /**
          * There is the possibility to change the base path of your application, using <code>base</code> HTML Element: <psk-example>    <psk-code>     <base href="/my-custom-base">    </psk-code> </psk-example>  Both <code>webc-app-menu</code> and <code>webc-app-router</code> must share the same <code>basePath</code>.
         */
        "basePath"?: string;
        /**
          * Decides if <code>webc-app-identity</code> is rendered.<br> This property is set by Custom Variable <code>--webc-app-menu-disable-identity</code>.
         */
        "disableIdentity"?: boolean;
        /**
          * This Array is received from <code>ApplicationController</code>.
         */
        "items"?: any[];
        "mode"?: string;
        /**
          * Routing configuration received from <code>ApplicationController</code>.<br> This configuration includes different settings for pages, skins, modals, etc.;
         */
        "onWebcardinal:config:getRouting"?: (event: CustomEvent<any>) => void;
    }
    interface WebcAppMenuItem {
        "basePath"?: string;
        "item"?: { path: string; children: any; };
        "level"?: number;
        "menuElement"?: HTMLElement;
        "mode"?: string;
        "name"?: string;
        "url"?: string | null;
    }
    interface WebcAppRedirect {
        "url"?: string;
    }
    interface WebcAppRoot {
        "history"?: RouterHistory;
        /**
          * Component tag name (in lowercase) for a UI loader.
         */
        "loaderName"?: string;
        /**
          * LogLevel configuration is received from <code>ApplicationController</code> when this event is fired.<br>
         */
        "onWebcardinal:config:getLogLevel"?: (event: CustomEvent<any>) => void;
    }
    interface WebcAppRouter {
        /**
          * There is the possibility to change the base path of your application, using <code>base</code> HTML Element: <psk-example>    <psk-code>     <base href="/my-custom-base">    </psk-code> </psk-example>  Both <code>webc-app-router</code> and <code>webc-app-menu</code> must share the same <code>basePath</code>.
         */
        "basePath"?: string;
        /**
          * Similar to 404 page, if <code>window.location.href</code> does not match any page, this fallback will be shown. This page can be changed from <code>webcardinal.json</code>, using <code>pagesFallback</code>.
         */
        "fallbackPage"?: any;
        /**
          * Routing configuration received from <code>ApplicationController</code>.<br> This configuration includes different settings for pages, skins, modals, etc.;
         */
        "onWebcardinal:config:getRouting"?: (event: CustomEvent<any>) => void;
        /**
          * Path to <code>/pages</code> folder.<br> This folder can be changed from <code>webcardinal.json</code>, using <code>pagesPathname</code>.
         */
        "pagesPath"?: string;
        /**
          * This Array is received from <code>ApplicationController</code>.
         */
        "routes"?: any[];
    }
    interface WebcContainer {
        /**
          * This property is a string that will permit the developer to choose his own controller. If no value is set then the null default value will be taken and the component will use the basic Controller.
         */
        "controllerName"?: string | null;
        /**
          * If it is not specified, all the innerHTML will be placed inside the unnamed slot. Otherwise the content will replace the <code>webc-container</code> element form DOM.
         */
        "disableContainer"?: boolean;
        /**
          * If this property is true, internationalization (i18n) will be enabled.
         */
        "enableTranslations"?: boolean;
        "history"?: RouterHistory;
        /**
          * Routing configuration received from <code>webc-app-router</code>.
         */
        "onWebcardinal:routing:get"?: (event: CustomEvent<any>) => void;
    }
    interface WebcDocs {
        /**
          * Component tag name (in lowercase) for which documentation is desired.
         */
        "for"?: string;
        /**
          * If this prop is set to <code>true</code> the source of fetched docs for current webc-docs component must be on your local workspace. Otherwise the source is <small><code>https://raw.githubusercontent.com</code></small>.
         */
        "local"?: boolean;
        /**
          * Gets the docs source for current component.<br> In <code>webcardinal.json</code>, if there is a key named <code>docsSource</code> with value <code>'local'</code>, all webc-docs components will be configured for local docs.<br> Default value for <code>docsSource</code> is <code>'github'</code>.
         */
        "onWebcardinal:config:getDocsSource"?: (event: CustomEvent<any>) => void;
    }
    interface WebcLink {
        "href"?: string | null;
        /**
          * Through this event a mapping (tag-page) with all tags is received from <code>webc-app-router</code>.
         */
        "onWebcardinal:tags:get"?: (event: CustomEvent<any>) => void;
        /**
          * A unique identifier for each page, which was previously set in <code>webcardinal.json</code>
         */
        "tag"?: string | null;
    }
    interface WebcModal {
        /**
          * Sets if the modal will automatically close when the user clicks outside of it.
         */
        "autoClose"?: boolean;
        /**
          * Sets if the modal will automatically show when the element is constructed.
         */
        "autoShow"?: boolean;
        /**
          * Sets if the modal can be closed
         */
        "canClose"?: boolean;
        /**
          * The text that will appear on the footer close button, if neither the "footer" slot nor modalFooterContent are provided.
         */
        "cancelButtonText"?: string;
        /**
          * Sets if the popup is centered on the screen or if it appear at the top of the screen.
         */
        "centered"?: boolean;
        /**
          * The text that will appear on the footer confirm button, if neither the "footer" slot nor modalFooterContent are provided.
         */
        "confirmButtonText"?: string;
        /**
          * The content that can be shown in the footer, if provided and the "footer" slot is missing from the content.
         */
        "modalFooterContent"?: string;
        /**
          * The name of the model that will be loaded. The generated path will have the format <code>${basePath}/modals/${modalName}.html</code>.
         */
        "modalName"?: string;
        /**
          * The text that will be shown in the modal's header, if neither the "title" slot nor modalTitleContent are provided.
         */
        "modalTitle"?: string;
        /**
          * The content that can be shown in the header, if provided and the "title" slot is missing from the content.
         */
        "modalTitleContent"?: string;
        /**
          * Event that fires when the modal is pressed (only when the default footer is shown). The event will be passed with a boolean value to specify if the popup was closed due to a button press (true) or a click outside of the popup (false)
         */
        "onClosed"?: (event: CustomEvent<boolean>) => void;
        /**
          * Event that fires when the confirm button is pressed (only when the default footer is shown).
         */
        "onConfirmed"?: (event: CustomEvent<any>) => void;
        /**
          * Event that fires when the modal is initialised (after the modal content was successfully loaded).
         */
        "onInitialised"?: (event: CustomEvent<HTMLElement>) => void;
        /**
          * Sets if the close button will be shown or not.
         */
        "showCancelButton"?: boolean;
        /**
          * Sets if the modal has the footer displayed.
         */
        "showFooter"?: boolean;
        /**
          * The content that will be shown in the modal body, if modalName is not provided.
         */
        "text"?: string;
    }
    interface WebcSkin {
        /**
          * Path to a stylesheet.
         */
        "href"?: string;
    }
    interface WebcSpinner {
    }
    interface WebcTemplate {
        "chain"?: string;
        /**
          * If it is not specified, all the markup coming <code>template</code> attribute will be placed inside innerHTML after the unnamed slot. Otherwise the content will replace the <code>webc-template</code> element form DOM.
         */
        "disableContainer"?: boolean;
        /**
          * Through this event model is received (from webc-container, webc-for, webc-if or any component that supports a controller).
         */
        "onWebcardinal:model:get"?: (event: CustomEvent<any>) => void;
        /**
          * Through this event translation model is received.
         */
        "onWebcardinal:translationModel:get"?: (event: CustomEvent<any>) => void;
        /**
          * The name of the template that will be loaded. The generated path will have the format <code>${basePath}/templates/${templateName}.html</code>.
         */
        "templateName"?: string;
    }
    interface IntrinsicElements {
        "webc-app-container": WebcAppContainer;
        "webc-app-error-toast": WebcAppErrorToast;
        "webc-app-identity": WebcAppIdentity;
        "webc-app-loader": WebcAppLoader;
        "webc-app-menu": WebcAppMenu;
        "webc-app-menu-item": WebcAppMenuItem;
        "webc-app-redirect": WebcAppRedirect;
        "webc-app-root": WebcAppRoot;
        "webc-app-router": WebcAppRouter;
        "webc-container": WebcContainer;
        "webc-docs": WebcDocs;
        "webc-link": WebcLink;
        "webc-modal": WebcModal;
        "webc-skin": WebcSkin;
        "webc-spinner": WebcSpinner;
        "webc-template": WebcTemplate;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "webc-app-container": LocalJSX.WebcAppContainer & JSXBase.HTMLAttributes<HTMLWebcAppContainerElement>;
            "webc-app-error-toast": LocalJSX.WebcAppErrorToast & JSXBase.HTMLAttributes<HTMLWebcAppErrorToastElement>;
            "webc-app-identity": LocalJSX.WebcAppIdentity & JSXBase.HTMLAttributes<HTMLWebcAppIdentityElement>;
            "webc-app-loader": LocalJSX.WebcAppLoader & JSXBase.HTMLAttributes<HTMLWebcAppLoaderElement>;
            "webc-app-menu": LocalJSX.WebcAppMenu & JSXBase.HTMLAttributes<HTMLWebcAppMenuElement>;
            "webc-app-menu-item": LocalJSX.WebcAppMenuItem & JSXBase.HTMLAttributes<HTMLWebcAppMenuItemElement>;
            "webc-app-redirect": LocalJSX.WebcAppRedirect & JSXBase.HTMLAttributes<HTMLWebcAppRedirectElement>;
            "webc-app-root": LocalJSX.WebcAppRoot & JSXBase.HTMLAttributes<HTMLWebcAppRootElement>;
            "webc-app-router": LocalJSX.WebcAppRouter & JSXBase.HTMLAttributes<HTMLWebcAppRouterElement>;
            "webc-container": LocalJSX.WebcContainer & JSXBase.HTMLAttributes<HTMLWebcContainerElement>;
            "webc-docs": LocalJSX.WebcDocs & JSXBase.HTMLAttributes<HTMLWebcDocsElement>;
            "webc-link": LocalJSX.WebcLink & JSXBase.HTMLAttributes<HTMLWebcLinkElement>;
            "webc-modal": LocalJSX.WebcModal & JSXBase.HTMLAttributes<HTMLWebcModalElement>;
            "webc-skin": LocalJSX.WebcSkin & JSXBase.HTMLAttributes<HTMLWebcSkinElement>;
            "webc-spinner": LocalJSX.WebcSpinner & JSXBase.HTMLAttributes<HTMLWebcSpinnerElement>;
            "webc-template": LocalJSX.WebcTemplate & JSXBase.HTMLAttributes<HTMLWebcTemplateElement>;
        }
    }
}
