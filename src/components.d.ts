/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { RouterHistory } from "@stencil/router";
export namespace Components {
    interface WebcAppContainer {
    }
    interface WebcAppErrorToast {
    }
    interface WebcAppIdentity {
        "avatar": string | null;
        "email": string | null;
        "name": string | null;
    }
    interface WebcAppLoader {
        "src": string;
        "type": string;
    }
    interface WebcAppMenu {
        "basePath": string;
        "disableIdentity": boolean;
        "history": RouterHistory;
        "items": any[];
        "mode": string;
    }
    interface WebcAppMenuItem {
        "activate": () => Promise<void>;
        "basePath": string;
        "deactivate": () => Promise<void>;
        "item": { path: string; children: any; };
        "level": number;
        "menuElement": HTMLElement;
        "mode": string;
        "name": string;
        "url": string | null;
    }
    interface WebcAppRoot {
        "history": RouterHistory;
        "loaderName": string;
    }
    interface WebcAppRouter {
        "basePath": string;
        "fallbackPage": null;
        "pagesPath": string;
        "routes": any[];
    }
    interface WebcBindable {
        "controllerName": string | null;
        "getModel": () => Promise<any>;
        "history": RouterHistory;
    }
    interface WebcContainer {
        "controllerName": string | null;
        "history": RouterHistory;
    }
    interface WebcFor {
        "autoBind": boolean;
        "chain": string;
        "controllerName": string | null;
        "history": RouterHistory;
    }
    interface WebcIf {
        /**
          * The condition that will be evaluated in order to check which slots will be visible
         */
        "condition": any | undefined;
        /**
          * An optional model that will be used to check the condition; if not provided, then the component will find the closes webc-bindable element and take the model from there
         */
        "model": any | undefined;
    }
    interface WebcLink {
        "href": string | null;
        "tag": string | null;
    }
    interface WebcModal {
        /**
          * Sets if the modal will automatically close when the user clicks outside of it
         */
        "autoClose": boolean;
        /**
          * Sets if the modal will automatically show when the element is constructed
         */
        "autoShow": boolean;
        /**
          * Sets if the modal can be closed
         */
        "canClose": boolean;
        /**
          * The text that will appear on the footer close button (if neither the "footer" slot nor modalFooterContent are provided)
         */
        "cancelButtonText": string;
        /**
          * Sets if the popup is centered on the screen or if it appear at the top of the screen
         */
        "centered": boolean;
        /**
          * The text that will appear on the footer confirm button (if neither the "footer" slot nor modalFooterContent are provided)
         */
        "confirmButtonText": string;
        /**
          * Method that completely removes the modal from the DOM.
         */
        "destroy": () => Promise<void>;
        /**
          * Method that hides the modal.
         */
        "hide": () => Promise<void>;
        /**
          * The content that can be shown in the footer, if provided and the "footer" slot is missing from the content.
         */
        "modalFooterContent": string;
        /**
          * The name of the model that will be loaded. The generated path will have the format ${basePath}/modals/${modalName}.html
         */
        "modalName": string;
        /**
          * The text that will be shown in the modal's header, if neither the "title" slot nor modalTitleContent are provided
         */
        "modalTitle": string;
        /**
          * The content that can be shown in the header, if provided and the "title" slot is missing from the content.
         */
        "modalTitleContent": string;
        /**
          * Method that shows the modal.
         */
        "show": () => Promise<void>;
        /**
          * Sets if the close button will be shown or not
         */
        "showCancelButton": boolean;
        /**
          * Sets if the modal has the footer displayed
         */
        "showFooter": boolean;
        /**
          * The content that will be shown in the modal body, if modalName is not provided
         */
        "text": string;
    }
    interface WebcPage {
        "controllerName": string | null;
        "enableTranslations": boolean;
        "getModel": () => Promise<any>;
        "getTranslationModel": () => Promise<any>;
        "history": RouterHistory;
    }
    interface WebcSkin {
    }
    interface WebcSpinner {
    }
    interface WebcTemplate {
        "chain": string;
        /**
          * The name of the template that will be loaded. The generated path will have the format ${basePath}/templates/${templateName}.html
         */
        "templateName": string;
    }
}
declare global {
    interface HTMLWebcAppContainerElement extends Components.WebcAppContainer, HTMLStencilElement {
    }
    var HTMLWebcAppContainerElement: {
        prototype: HTMLWebcAppContainerElement;
        new (): HTMLWebcAppContainerElement;
    };
    interface HTMLWebcAppErrorToastElement extends Components.WebcAppErrorToast, HTMLStencilElement {
    }
    var HTMLWebcAppErrorToastElement: {
        prototype: HTMLWebcAppErrorToastElement;
        new (): HTMLWebcAppErrorToastElement;
    };
    interface HTMLWebcAppIdentityElement extends Components.WebcAppIdentity, HTMLStencilElement {
    }
    var HTMLWebcAppIdentityElement: {
        prototype: HTMLWebcAppIdentityElement;
        new (): HTMLWebcAppIdentityElement;
    };
    interface HTMLWebcAppLoaderElement extends Components.WebcAppLoader, HTMLStencilElement {
    }
    var HTMLWebcAppLoaderElement: {
        prototype: HTMLWebcAppLoaderElement;
        new (): HTMLWebcAppLoaderElement;
    };
    interface HTMLWebcAppMenuElement extends Components.WebcAppMenu, HTMLStencilElement {
    }
    var HTMLWebcAppMenuElement: {
        prototype: HTMLWebcAppMenuElement;
        new (): HTMLWebcAppMenuElement;
    };
    interface HTMLWebcAppMenuItemElement extends Components.WebcAppMenuItem, HTMLStencilElement {
    }
    var HTMLWebcAppMenuItemElement: {
        prototype: HTMLWebcAppMenuItemElement;
        new (): HTMLWebcAppMenuItemElement;
    };
    interface HTMLWebcAppRootElement extends Components.WebcAppRoot, HTMLStencilElement {
    }
    var HTMLWebcAppRootElement: {
        prototype: HTMLWebcAppRootElement;
        new (): HTMLWebcAppRootElement;
    };
    interface HTMLWebcAppRouterElement extends Components.WebcAppRouter, HTMLStencilElement {
    }
    var HTMLWebcAppRouterElement: {
        prototype: HTMLWebcAppRouterElement;
        new (): HTMLWebcAppRouterElement;
    };
    interface HTMLWebcBindableElement extends Components.WebcBindable, HTMLStencilElement {
    }
    var HTMLWebcBindableElement: {
        prototype: HTMLWebcBindableElement;
        new (): HTMLWebcBindableElement;
    };
    interface HTMLWebcContainerElement extends Components.WebcContainer, HTMLStencilElement {
    }
    var HTMLWebcContainerElement: {
        prototype: HTMLWebcContainerElement;
        new (): HTMLWebcContainerElement;
    };
    interface HTMLWebcForElement extends Components.WebcFor, HTMLStencilElement {
    }
    var HTMLWebcForElement: {
        prototype: HTMLWebcForElement;
        new (): HTMLWebcForElement;
    };
    interface HTMLWebcIfElement extends Components.WebcIf, HTMLStencilElement {
    }
    var HTMLWebcIfElement: {
        prototype: HTMLWebcIfElement;
        new (): HTMLWebcIfElement;
    };
    interface HTMLWebcLinkElement extends Components.WebcLink, HTMLStencilElement {
    }
    var HTMLWebcLinkElement: {
        prototype: HTMLWebcLinkElement;
        new (): HTMLWebcLinkElement;
    };
    interface HTMLWebcModalElement extends Components.WebcModal, HTMLStencilElement {
    }
    var HTMLWebcModalElement: {
        prototype: HTMLWebcModalElement;
        new (): HTMLWebcModalElement;
    };
    interface HTMLWebcPageElement extends Components.WebcPage, HTMLStencilElement {
    }
    var HTMLWebcPageElement: {
        prototype: HTMLWebcPageElement;
        new (): HTMLWebcPageElement;
    };
    interface HTMLWebcSkinElement extends Components.WebcSkin, HTMLStencilElement {
    }
    var HTMLWebcSkinElement: {
        prototype: HTMLWebcSkinElement;
        new (): HTMLWebcSkinElement;
    };
    interface HTMLWebcSpinnerElement extends Components.WebcSpinner, HTMLStencilElement {
    }
    var HTMLWebcSpinnerElement: {
        prototype: HTMLWebcSpinnerElement;
        new (): HTMLWebcSpinnerElement;
    };
    interface HTMLWebcTemplateElement extends Components.WebcTemplate, HTMLStencilElement {
    }
    var HTMLWebcTemplateElement: {
        prototype: HTMLWebcTemplateElement;
        new (): HTMLWebcTemplateElement;
    };
    interface HTMLElementTagNameMap {
        "webc-app-container": HTMLWebcAppContainerElement;
        "webc-app-error-toast": HTMLWebcAppErrorToastElement;
        "webc-app-identity": HTMLWebcAppIdentityElement;
        "webc-app-loader": HTMLWebcAppLoaderElement;
        "webc-app-menu": HTMLWebcAppMenuElement;
        "webc-app-menu-item": HTMLWebcAppMenuItemElement;
        "webc-app-root": HTMLWebcAppRootElement;
        "webc-app-router": HTMLWebcAppRouterElement;
        "webc-bindable": HTMLWebcBindableElement;
        "webc-container": HTMLWebcContainerElement;
        "webc-for": HTMLWebcForElement;
        "webc-if": HTMLWebcIfElement;
        "webc-link": HTMLWebcLinkElement;
        "webc-modal": HTMLWebcModalElement;
        "webc-page": HTMLWebcPageElement;
        "webc-skin": HTMLWebcSkinElement;
        "webc-spinner": HTMLWebcSpinnerElement;
        "webc-template": HTMLWebcTemplateElement;
    }
}
declare namespace LocalJSX {
    interface WebcAppContainer {
    }
    interface WebcAppErrorToast {
    }
    interface WebcAppIdentity {
        "avatar"?: string | null;
        "email"?: string | null;
        "name"?: string | null;
        "onWebcardinal:config:getIdentity"?: (event: CustomEvent<any>) => void;
    }
    interface WebcAppLoader {
        "src"?: string;
        "type"?: string;
    }
    interface WebcAppMenu {
        "basePath"?: string;
        "disableIdentity"?: boolean;
        "history"?: RouterHistory;
        "items"?: any[];
        "mode"?: string;
        "onWebcardinal:config:getRouting"?: (event: CustomEvent<any>) => void;
    }
    interface WebcAppMenuItem {
        "basePath"?: string;
        "item"?: { path: string; children: any; };
        "level"?: number;
        "menuElement"?: HTMLElement;
        "mode"?: string;
        "name"?: string;
        "url"?: string | null;
    }
    interface WebcAppRoot {
        "history"?: RouterHistory;
        "loaderName"?: string;
        "onWebcardinal:config:getLogLevel"?: (event: CustomEvent<any>) => void;
    }
    interface WebcAppRouter {
        "basePath"?: string;
        "fallbackPage"?: null;
        "onWebcardinal:config:getRouting"?: (event: CustomEvent<any>) => void;
        "pagesPath"?: string;
        "routes"?: any[];
    }
    interface WebcBindable {
        "controllerName"?: string | null;
        "history"?: RouterHistory;
        "onWebcardinal:routing:get"?: (event: CustomEvent<any>) => void;
    }
    interface WebcContainer {
        "controllerName"?: string | null;
        "history"?: RouterHistory;
    }
    interface WebcFor {
        "autoBind"?: boolean;
        "chain"?: string;
        "controllerName"?: string | null;
        "history"?: RouterHistory;
        "onWebcardinal:model:get"?: (event: CustomEvent<any>) => void;
        "onWebcardinal:translationModel:get"?: (event: CustomEvent<any>) => void;
    }
    interface WebcIf {
        /**
          * The condition that will be evaluated in order to check which slots will be visible
         */
        "condition"?: any | undefined;
        /**
          * An optional model that will be used to check the condition; if not provided, then the component will find the closes webc-bindable element and take the model from there
         */
        "model"?: any | undefined;
        "onWebcardinal:model:get"?: (event: CustomEvent<any>) => void;
        "onWebcardinal:translationModel:get"?: (event: CustomEvent<any>) => void;
    }
    interface WebcLink {
        "href"?: string | null;
        "onWebcardinal:tags:get"?: (event: CustomEvent<any>) => void;
        "tag"?: string | null;
    }
    interface WebcModal {
        /**
          * Sets if the modal will automatically close when the user clicks outside of it
         */
        "autoClose"?: boolean;
        /**
          * Sets if the modal will automatically show when the element is constructed
         */
        "autoShow"?: boolean;
        /**
          * Sets if the modal can be closed
         */
        "canClose"?: boolean;
        /**
          * The text that will appear on the footer close button (if neither the "footer" slot nor modalFooterContent are provided)
         */
        "cancelButtonText"?: string;
        /**
          * Sets if the popup is centered on the screen or if it appear at the top of the screen
         */
        "centered"?: boolean;
        /**
          * The text that will appear on the footer confirm button (if neither the "footer" slot nor modalFooterContent are provided)
         */
        "confirmButtonText"?: string;
        /**
          * The content that can be shown in the footer, if provided and the "footer" slot is missing from the content.
         */
        "modalFooterContent"?: string;
        /**
          * The name of the model that will be loaded. The generated path will have the format ${basePath}/modals/${modalName}.html
         */
        "modalName"?: string;
        /**
          * The text that will be shown in the modal's header, if neither the "title" slot nor modalTitleContent are provided
         */
        "modalTitle"?: string;
        /**
          * The content that can be shown in the header, if provided and the "title" slot is missing from the content.
         */
        "modalTitleContent"?: string;
        /**
          * Event that fires when the modal is pressed (only when the default footer is shown). The event will be passed with a boolean value to specify if the popup was closed due to a button press (true) or a click outside of the popup (false)
         */
        "onClosed"?: (event: CustomEvent<boolean>) => void;
        /**
          * Event that fires when the confirm button is pressed (only when the default footer is shown)
         */
        "onConfirmed"?: (event: CustomEvent<any>) => void;
        /**
          * Event that fires when the modal is initialised (after the modal content was successfully loaded)
         */
        "onInitialised"?: (event: CustomEvent<HTMLElement>) => void;
        /**
          * Sets if the close button will be shown or not
         */
        "showCancelButton"?: boolean;
        /**
          * Sets if the modal has the footer displayed
         */
        "showFooter"?: boolean;
        /**
          * The content that will be shown in the modal body, if modalName is not provided
         */
        "text"?: string;
    }
    interface WebcPage {
        "controllerName"?: string | null;
        "enableTranslations"?: boolean;
        "history"?: RouterHistory;
        "onWebcardinal:routing:get"?: (event: CustomEvent<any>) => void;
    }
    interface WebcSkin {
    }
    interface WebcSpinner {
    }
    interface WebcTemplate {
        "chain"?: string;
        "onWebcardinal:model:get"?: (event: CustomEvent<any>) => void;
        "onWebcardinal:translationModel:get"?: (event: CustomEvent<any>) => void;
        /**
          * The name of the template that will be loaded. The generated path will have the format ${basePath}/templates/${templateName}.html
         */
        "templateName"?: string;
    }
    interface IntrinsicElements {
        "webc-app-container": WebcAppContainer;
        "webc-app-error-toast": WebcAppErrorToast;
        "webc-app-identity": WebcAppIdentity;
        "webc-app-loader": WebcAppLoader;
        "webc-app-menu": WebcAppMenu;
        "webc-app-menu-item": WebcAppMenuItem;
        "webc-app-root": WebcAppRoot;
        "webc-app-router": WebcAppRouter;
        "webc-bindable": WebcBindable;
        "webc-container": WebcContainer;
        "webc-for": WebcFor;
        "webc-if": WebcIf;
        "webc-link": WebcLink;
        "webc-modal": WebcModal;
        "webc-page": WebcPage;
        "webc-skin": WebcSkin;
        "webc-spinner": WebcSpinner;
        "webc-template": WebcTemplate;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "webc-app-container": LocalJSX.WebcAppContainer & JSXBase.HTMLAttributes<HTMLWebcAppContainerElement>;
            "webc-app-error-toast": LocalJSX.WebcAppErrorToast & JSXBase.HTMLAttributes<HTMLWebcAppErrorToastElement>;
            "webc-app-identity": LocalJSX.WebcAppIdentity & JSXBase.HTMLAttributes<HTMLWebcAppIdentityElement>;
            "webc-app-loader": LocalJSX.WebcAppLoader & JSXBase.HTMLAttributes<HTMLWebcAppLoaderElement>;
            "webc-app-menu": LocalJSX.WebcAppMenu & JSXBase.HTMLAttributes<HTMLWebcAppMenuElement>;
            "webc-app-menu-item": LocalJSX.WebcAppMenuItem & JSXBase.HTMLAttributes<HTMLWebcAppMenuItemElement>;
            "webc-app-root": LocalJSX.WebcAppRoot & JSXBase.HTMLAttributes<HTMLWebcAppRootElement>;
            "webc-app-router": LocalJSX.WebcAppRouter & JSXBase.HTMLAttributes<HTMLWebcAppRouterElement>;
            "webc-bindable": LocalJSX.WebcBindable & JSXBase.HTMLAttributes<HTMLWebcBindableElement>;
            "webc-container": LocalJSX.WebcContainer & JSXBase.HTMLAttributes<HTMLWebcContainerElement>;
            "webc-for": LocalJSX.WebcFor & JSXBase.HTMLAttributes<HTMLWebcForElement>;
            "webc-if": LocalJSX.WebcIf & JSXBase.HTMLAttributes<HTMLWebcIfElement>;
            "webc-link": LocalJSX.WebcLink & JSXBase.HTMLAttributes<HTMLWebcLinkElement>;
            "webc-modal": LocalJSX.WebcModal & JSXBase.HTMLAttributes<HTMLWebcModalElement>;
            "webc-page": LocalJSX.WebcPage & JSXBase.HTMLAttributes<HTMLWebcPageElement>;
            "webc-skin": LocalJSX.WebcSkin & JSXBase.HTMLAttributes<HTMLWebcSkinElement>;
            "webc-spinner": LocalJSX.WebcSpinner & JSXBase.HTMLAttributes<HTMLWebcSpinnerElement>;
            "webc-template": LocalJSX.WebcTemplate & JSXBase.HTMLAttributes<HTMLWebcTemplateElement>;
        }
    }
}
