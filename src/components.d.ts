/* eslint-disable */
/* tslint:disable */
/**
 * This is an autogenerated file created by the Stencil compiler.
 * It contains typing information for all components that exist in this project.
 */
import { HTMLStencilElement, JSXBase } from "@stencil/core/internal";
import { RouterHistory } from "@stencil/router";
export namespace Components {
    interface WccAppContainer {
    }
    interface WccAppErrorToast {
    }
    interface WccAppIdentity {
        "avatar": string | null;
        "email": string | null;
        "name": string | null;
    }
    interface WccAppLoader {
        "src": string;
        "type": string;
    }
    interface WccAppMenu {
        "basePath": string;
        "disableIdentity": boolean;
        "items": any[];
        "mode": string;
    }
    interface WccAppMenuItem {
        "basePath": string;
        "item": { path: string; children: any; };
        "level": number;
        "menuElement": HTMLElement;
        "mode": string;
        "name": string;
        "url": string | null;
    }
    interface WccAppRoot {
        "history": RouterHistory;
        "loaderName": string;
    }
    interface WccAppRouter {
        "basePath": string;
        "fallbackPage": null;
        "pagesPath": string;
        "routes": any[];
    }
    interface WccBindable {
        "controllerName": string | null;
        "getModel": () => Promise<any>;
        "history": RouterHistory;
    }
    interface WccContainer {
        "controllerName": string | null;
        "history": RouterHistory;
    }
    interface WccFor {
        "autoBind": boolean;
        "chain": string;
        "controllerName": string | null;
        "history": RouterHistory;
    }
    interface WccIf {
        /**
          * The condition that will be evaluated in order to check which slots will be visible
         */
        "condition": any | undefined;
        /**
          * An optional modal that will be used to check the condition; if not provided, then the component will find the closes wcc-bindable element and take the model from there
         */
        "model": any | undefined;
    }
    interface WccLink {
        "href": string | null;
        "tag": string | null;
    }
    interface WccModal {
        /**
          * Sets if the modal will automatically close when the user clicks outside of it
         */
        "autoClose": boolean;
        /**
          * Sets if the modal will automatically show when the element is constructed
         */
        "autoShow": boolean;
        /**
          * Sets if the modal can be closed
         */
        "canClose": boolean;
        /**
          * The text that will appear on the footer close button (if neither the "footer" slot nor modalFooterContent are provided)
         */
        "cancelButtonText": string;
        /**
          * Sets if the popup is centered on the screen or if it appear at the top of the screen
         */
        "centered": boolean;
        /**
          * The text that will appear on the footer confirm button (if neither the "footer" slot nor modalFooterContent are provided)
         */
        "confirmButtonText": string;
        /**
          * Method that completely removes the modal from the DOM.
         */
        "destroy": () => Promise<void>;
        /**
          * Method that hides the modal.
         */
        "hide": () => Promise<void>;
        /**
          * The content that can be shown in the footer, if provided and the "footer" slot is missing from the content.
         */
        "modalFooterContent": string;
        /**
          * The name of the model that will be loaded. The generated path will have the format ${basePath}/modals/${modalName}.html
         */
        "modalName": string;
        /**
          * The text that will be shown in the modal's header, if neither the "title" slot nor modalTitleContent are provided
         */
        "modalTitle": string;
        /**
          * The content that can be shown in the header, if provided and the "title" slot is missing from the content.
         */
        "modalTitleContent": string;
        /**
          * Method that shows the modal.
         */
        "show": () => Promise<void>;
        /**
          * Sets if the close button will be shown or not
         */
        "showCancelButton": boolean;
        /**
          * Sets if the modal has the footer displayed
         */
        "showFooter": boolean;
        /**
          * The content that will be shown in the modal body, if modalName is not provided
         */
        "text": string;
    }
    interface WccSpinner {
    }
}
declare global {
    interface HTMLWccAppContainerElement extends Components.WccAppContainer, HTMLStencilElement {
    }
    var HTMLWccAppContainerElement: {
        prototype: HTMLWccAppContainerElement;
        new (): HTMLWccAppContainerElement;
    };
    interface HTMLWccAppErrorToastElement extends Components.WccAppErrorToast, HTMLStencilElement {
    }
    var HTMLWccAppErrorToastElement: {
        prototype: HTMLWccAppErrorToastElement;
        new (): HTMLWccAppErrorToastElement;
    };
    interface HTMLWccAppIdentityElement extends Components.WccAppIdentity, HTMLStencilElement {
    }
    var HTMLWccAppIdentityElement: {
        prototype: HTMLWccAppIdentityElement;
        new (): HTMLWccAppIdentityElement;
    };
    interface HTMLWccAppLoaderElement extends Components.WccAppLoader, HTMLStencilElement {
    }
    var HTMLWccAppLoaderElement: {
        prototype: HTMLWccAppLoaderElement;
        new (): HTMLWccAppLoaderElement;
    };
    interface HTMLWccAppMenuElement extends Components.WccAppMenu, HTMLStencilElement {
    }
    var HTMLWccAppMenuElement: {
        prototype: HTMLWccAppMenuElement;
        new (): HTMLWccAppMenuElement;
    };
    interface HTMLWccAppMenuItemElement extends Components.WccAppMenuItem, HTMLStencilElement {
    }
    var HTMLWccAppMenuItemElement: {
        prototype: HTMLWccAppMenuItemElement;
        new (): HTMLWccAppMenuItemElement;
    };
    interface HTMLWccAppRootElement extends Components.WccAppRoot, HTMLStencilElement {
    }
    var HTMLWccAppRootElement: {
        prototype: HTMLWccAppRootElement;
        new (): HTMLWccAppRootElement;
    };
    interface HTMLWccAppRouterElement extends Components.WccAppRouter, HTMLStencilElement {
    }
    var HTMLWccAppRouterElement: {
        prototype: HTMLWccAppRouterElement;
        new (): HTMLWccAppRouterElement;
    };
    interface HTMLWccBindableElement extends Components.WccBindable, HTMLStencilElement {
    }
    var HTMLWccBindableElement: {
        prototype: HTMLWccBindableElement;
        new (): HTMLWccBindableElement;
    };
    interface HTMLWccContainerElement extends Components.WccContainer, HTMLStencilElement {
    }
    var HTMLWccContainerElement: {
        prototype: HTMLWccContainerElement;
        new (): HTMLWccContainerElement;
    };
    interface HTMLWccForElement extends Components.WccFor, HTMLStencilElement {
    }
    var HTMLWccForElement: {
        prototype: HTMLWccForElement;
        new (): HTMLWccForElement;
    };
    interface HTMLWccIfElement extends Components.WccIf, HTMLStencilElement {
    }
    var HTMLWccIfElement: {
        prototype: HTMLWccIfElement;
        new (): HTMLWccIfElement;
    };
    interface HTMLWccLinkElement extends Components.WccLink, HTMLStencilElement {
    }
    var HTMLWccLinkElement: {
        prototype: HTMLWccLinkElement;
        new (): HTMLWccLinkElement;
    };
    interface HTMLWccModalElement extends Components.WccModal, HTMLStencilElement {
    }
    var HTMLWccModalElement: {
        prototype: HTMLWccModalElement;
        new (): HTMLWccModalElement;
    };
    interface HTMLWccSpinnerElement extends Components.WccSpinner, HTMLStencilElement {
    }
    var HTMLWccSpinnerElement: {
        prototype: HTMLWccSpinnerElement;
        new (): HTMLWccSpinnerElement;
    };
    interface HTMLElementTagNameMap {
        "wcc-app-container": HTMLWccAppContainerElement;
        "wcc-app-error-toast": HTMLWccAppErrorToastElement;
        "wcc-app-identity": HTMLWccAppIdentityElement;
        "wcc-app-loader": HTMLWccAppLoaderElement;
        "wcc-app-menu": HTMLWccAppMenuElement;
        "wcc-app-menu-item": HTMLWccAppMenuItemElement;
        "wcc-app-root": HTMLWccAppRootElement;
        "wcc-app-router": HTMLWccAppRouterElement;
        "wcc-bindable": HTMLWccBindableElement;
        "wcc-container": HTMLWccContainerElement;
        "wcc-for": HTMLWccForElement;
        "wcc-if": HTMLWccIfElement;
        "wcc-link": HTMLWccLinkElement;
        "wcc-modal": HTMLWccModalElement;
        "wcc-spinner": HTMLWccSpinnerElement;
    }
}
declare namespace LocalJSX {
    interface WccAppContainer {
    }
    interface WccAppErrorToast {
    }
    interface WccAppIdentity {
        "avatar"?: string | null;
        "email"?: string | null;
        "name"?: string | null;
        "onWebcardinal:config:getIdentity"?: (event: CustomEvent<any>) => void;
    }
    interface WccAppLoader {
        "src"?: string;
        "type"?: string;
    }
    interface WccAppMenu {
        "basePath"?: string;
        "disableIdentity"?: boolean;
        "items"?: any[];
        "mode"?: string;
        "onWebcardinal:config:getRouting"?: (event: CustomEvent<any>) => void;
    }
    interface WccAppMenuItem {
        "basePath"?: string;
        "item"?: { path: string; children: any; };
        "level"?: number;
        "menuElement"?: HTMLElement;
        "mode"?: string;
        "name"?: string;
        "url"?: string | null;
    }
    interface WccAppRoot {
        "history"?: RouterHistory;
        "loaderName"?: string;
        "onWebcardinal:config:getLogLevel"?: (event: CustomEvent<any>) => void;
    }
    interface WccAppRouter {
        "basePath"?: string;
        "fallbackPage"?: null;
        "onWebcardinal:config:getRouting"?: (event: CustomEvent<any>) => void;
        "pagesPath"?: string;
        "routes"?: any[];
    }
    interface WccBindable {
        "controllerName"?: string | null;
        "history"?: RouterHistory;
    }
    interface WccContainer {
        "controllerName"?: string | null;
        "history"?: RouterHistory;
    }
    interface WccFor {
        "autoBind"?: boolean;
        "chain"?: string;
        "controllerName"?: string | null;
        "history"?: RouterHistory;
        "onWebcardinal:model:get"?: (event: CustomEvent<any>) => void;
    }
    interface WccIf {
        /**
          * The condition that will be evaluated in order to check which slots will be visible
         */
        "condition"?: any | undefined;
        /**
          * An optional modal that will be used to check the condition; if not provided, then the component will find the closes wcc-bindable element and take the model from there
         */
        "model"?: any | undefined;
    }
    interface WccLink {
        "href"?: string | null;
        "onWebcardinal:tags:get"?: (event: CustomEvent<any>) => void;
        "tag"?: string | null;
    }
    interface WccModal {
        /**
          * Sets if the modal will automatically close when the user clicks outside of it
         */
        "autoClose"?: boolean;
        /**
          * Sets if the modal will automatically show when the element is constructed
         */
        "autoShow"?: boolean;
        /**
          * Sets if the modal can be closed
         */
        "canClose"?: boolean;
        /**
          * The text that will appear on the footer close button (if neither the "footer" slot nor modalFooterContent are provided)
         */
        "cancelButtonText"?: string;
        /**
          * Sets if the popup is centered on the screen or if it appear at the top of the screen
         */
        "centered"?: boolean;
        /**
          * The text that will appear on the footer confirm button (if neither the "footer" slot nor modalFooterContent are provided)
         */
        "confirmButtonText"?: string;
        /**
          * The content that can be shown in the footer, if provided and the "footer" slot is missing from the content.
         */
        "modalFooterContent"?: string;
        /**
          * The name of the model that will be loaded. The generated path will have the format ${basePath}/modals/${modalName}.html
         */
        "modalName"?: string;
        /**
          * The text that will be shown in the modal's header, if neither the "title" slot nor modalTitleContent are provided
         */
        "modalTitle"?: string;
        /**
          * The content that can be shown in the header, if provided and the "title" slot is missing from the content.
         */
        "modalTitleContent"?: string;
        /**
          * Event that fires when the modal is pressed (only when the default footer is shown). The event will be passed with a boolean value to specify if the popup was closed due to a button press (true) or a click outside of the popup (false)
         */
        "onClosed"?: (event: CustomEvent<boolean>) => void;
        /**
          * Event that fires when the confirm button is pressed (only when the default footer is shown)
         */
        "onConfirmed"?: (event: CustomEvent<any>) => void;
        /**
          * Event that fires when the modal is initialised (after the modal content was successfully loaded)
         */
        "onInitialised"?: (event: CustomEvent<HTMLElement>) => void;
        /**
          * Sets if the close button will be shown or not
         */
        "showCancelButton"?: boolean;
        /**
          * Sets if the modal has the footer displayed
         */
        "showFooter"?: boolean;
        /**
          * The content that will be shown in the modal body, if modalName is not provided
         */
        "text"?: string;
    }
    interface WccSpinner {
    }
    interface IntrinsicElements {
        "wcc-app-container": WccAppContainer;
        "wcc-app-error-toast": WccAppErrorToast;
        "wcc-app-identity": WccAppIdentity;
        "wcc-app-loader": WccAppLoader;
        "wcc-app-menu": WccAppMenu;
        "wcc-app-menu-item": WccAppMenuItem;
        "wcc-app-root": WccAppRoot;
        "wcc-app-router": WccAppRouter;
        "wcc-bindable": WccBindable;
        "wcc-container": WccContainer;
        "wcc-for": WccFor;
        "wcc-if": WccIf;
        "wcc-link": WccLink;
        "wcc-modal": WccModal;
        "wcc-spinner": WccSpinner;
    }
}
export { LocalJSX as JSX };
declare module "@stencil/core" {
    export namespace JSX {
        interface IntrinsicElements {
            "wcc-app-container": LocalJSX.WccAppContainer & JSXBase.HTMLAttributes<HTMLWccAppContainerElement>;
            "wcc-app-error-toast": LocalJSX.WccAppErrorToast & JSXBase.HTMLAttributes<HTMLWccAppErrorToastElement>;
            "wcc-app-identity": LocalJSX.WccAppIdentity & JSXBase.HTMLAttributes<HTMLWccAppIdentityElement>;
            "wcc-app-loader": LocalJSX.WccAppLoader & JSXBase.HTMLAttributes<HTMLWccAppLoaderElement>;
            "wcc-app-menu": LocalJSX.WccAppMenu & JSXBase.HTMLAttributes<HTMLWccAppMenuElement>;
            "wcc-app-menu-item": LocalJSX.WccAppMenuItem & JSXBase.HTMLAttributes<HTMLWccAppMenuItemElement>;
            "wcc-app-root": LocalJSX.WccAppRoot & JSXBase.HTMLAttributes<HTMLWccAppRootElement>;
            "wcc-app-router": LocalJSX.WccAppRouter & JSXBase.HTMLAttributes<HTMLWccAppRouterElement>;
            "wcc-bindable": LocalJSX.WccBindable & JSXBase.HTMLAttributes<HTMLWccBindableElement>;
            "wcc-container": LocalJSX.WccContainer & JSXBase.HTMLAttributes<HTMLWccContainerElement>;
            "wcc-for": LocalJSX.WccFor & JSXBase.HTMLAttributes<HTMLWccForElement>;
            "wcc-if": LocalJSX.WccIf & JSXBase.HTMLAttributes<HTMLWccIfElement>;
            "wcc-link": LocalJSX.WccLink & JSXBase.HTMLAttributes<HTMLWccLinkElement>;
            "wcc-modal": LocalJSX.WccModal & JSXBase.HTMLAttributes<HTMLWccModalElement>;
            "wcc-spinner": LocalJSX.WccSpinner & JSXBase.HTMLAttributes<HTMLWccSpinnerElement>;
        }
    }
}
